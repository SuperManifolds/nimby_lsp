# NimbyScript API Definitions for NIMBY Rails v1
# These definitions provide completions and hover info for game types and functions
# Refer to https://wiki.nimbyrails.com/NimbyScript

version = "1.0.0"
api_version = "nimbyrails.v1"

# ============================================
# Standard Library Functions
# ============================================

[[functions]]
name = "abs"
doc = "Returns the absolute value of a number"
return_type = "f64"
[[functions.params]]
name = "value"
type = "f64"

[[functions]]
name = "ceil"
doc = "Returns the smallest integer greater than or equal to a number"
return_type = "f64"
[[functions.params]]
name = "value"
type = "f64"

[[functions]]
name = "floor"
doc = "Returns the largest integer less than or equal to a number"
return_type = "f64"
[[functions.params]]
name = "value"
type = "f64"

[[functions]]
name = "round"
doc = "Returns the nearest integer to a number"
return_type = "f64"
[[functions.params]]
name = "value"
type = "f64"

[[functions]]
name = "sqrt"
doc = "Returns the square root of a number"
return_type = "f64"
[[functions.params]]
name = "value"
type = "f64"

[[functions]]
name = "pow"
doc = "Returns base raised to the power of exponent"
return_type = "f64"
[[functions.params]]
name = "base"
type = "f64"
[[functions.params]]
name = "exponent"
type = "f64"

[[functions]]
name = "exp"
doc = "Returns e raised to the power of value"
return_type = "f64"
[[functions.params]]
name = "value"
type = "f64"

[[functions]]
name = "log10"
doc = "Returns the base-10 logarithm"
return_type = "f64"
[[functions.params]]
name = "value"
type = "f64"

[[functions]]
name = "loge"
doc = "Returns the natural logarithm"
return_type = "f64"
[[functions.params]]
name = "value"
type = "f64"

[[functions]]
name = "min"
doc = "Returns the smaller of two values"
return_type = "f64"
[[functions.params]]
name = "a"
type = "f64"
[[functions.params]]
name = "b"
type = "f64"

[[functions]]
name = "max"
doc = "Returns the larger of two values"
return_type = "f64"
[[functions.params]]
name = "a"
type = "f64"
[[functions.params]]
name = "b"
type = "f64"

[[functions]]
name = "zdiv"
doc = "Safe division that returns 0 when dividing by zero"
return_type = "i64"
[[functions.params]]
name = "numerator"
type = "i64"
[[functions.params]]
name = "denominator"
type = "i64"

[[functions]]
name = "zmod"
doc = "Safe modulo that returns 0 when dividing by zero"
return_type = "i64"
[[functions.params]]
name = "value"
type = "i64"
[[functions.params]]
name = "divisor"
type = "i64"

[[functions]]
name = "is_nan"
doc = "Returns true if the value is NaN"
return_type = "bool"
[[functions.params]]
name = "value"
type = "f64"

[[functions]]
name = "is_inf"
doc = "Returns true if the value is infinite"
return_type = "bool"
[[functions.params]]
name = "value"
type = "f64"

[[functions]]
name = "is_normal"
doc = "Returns true if the value is a normal floating-point number"
return_type = "bool"
[[functions.params]]
name = "value"
type = "f64"

[[functions]]
name = "iround"
doc = "Rounds a floating-point number to the nearest i64"
return_type = "i64"
[[functions.params]]
name = "value"
type = "f64"

[[functions]]
name = "is_valid"
doc = "Returns true if the ID references a valid entity"
return_type = "bool"
type_params = ["T"]
[[functions.params]]
name = "id"
type = "ID<T>"

[[functions]]
name = "is_valid"
doc = "Returns true if the pointer is valid (non-null)"
return_type = "bool"
type_params = ["T"]
[[functions.params]]
name = "ptr"
type = "*T"

[[functions]]
name = "as_i64"
doc = "Convert to i64"
return_type = "i64"
[[functions.params]]
name = "value"
type = "f64"

[[functions]]
name = "as_f64"
doc = "Convert to f64"
return_type = "f64"
[[functions.params]]
name = "value"
type = "i64"

[[functions]]
name = "log"
doc = "Log a formatted message for debugging"
[[functions.params]]
name = "format"
type = "string"

# ============================================
# Context Types (DB, Sim, Extrapolator, ControlCtx)
# ============================================

[types.ControlCtx]
kind = "struct"
doc = "Accessible game state for sim controller scripts"
[types.ControlCtx.fields]
db = { type = "&DB", doc = "Database reference" }
sim = { type = "&Sim", doc = "Simulation reference" }
extrapolator = { type = "&Extrapolator", doc = "Extrapolator reference" }

[types.DB]
kind = "struct"
doc = "The database of all player-created objects, and associated script struct objects"

[[types.DB.methods]]
name = "view"
doc = "Returns a reference to script data attached to a game object"
return_type = "*T"
type_params = ["T"]
[[types.DB.methods.params]]
name = "id"
type = "ID<T>"

[[types.DB.methods]]
name = "track_pos_project"
doc = "Returns a track position separated by 'distance' meters from 'pos', in the direction of 'pos'. If distance is negative it will be in the opposite direction. Only follows the main track, ignores signals, may return shorter distance at merges or dead ends."
return_type = "Pos"
[[types.DB.methods.params]]
name = "pos"
type = "&Pos"
[[types.DB.methods.params]]
name = "distance"
type = "f64"

[types.Sim]
kind = "struct"
doc = "The database of the simulation state"

[[types.Sim.methods]]
name = "view"
doc = "Returns a reference to simulation data for an entity"
return_type = "*T"
type_params = ["T"]
[[types.Sim.methods.params]]
name = "id"
type = "ID<T>"

[types.Extrapolator]
kind = "struct"
doc = "The simulation system tasked with train motion and scheduling"

# ============================================
# Game Types
# ============================================

[types.Script]
kind = "struct"
doc = "Base type for script instances attached to game objects"
[types.Script.fields]
id = { type = "ID<Script>", doc = "Unique identifier", readonly = true }

[types.Signal]
kind = "struct"
doc = "A railway signal that controls train movement"
[types.Signal.fields]
id = { type = "ID<Signal>", doc = "Unique identifier", readonly = true }
match_block_facing = { type = "bool", doc = "Match block facing direction" }
check_beyond_stops = { type = "bool", doc = "Check beyond stops" }

[[types.Signal.methods]]
name = "forward"
doc = "Get forward position"
return_type = "Pos"

[[types.Signal.methods]]
name = "backward"
doc = "Get backward position"
return_type = "Pos"

[[types.Signal.methods]]
name = "kind"
doc = "Get signal kind"
return_type = "SignalKind"

[types.Train]
kind = "struct"
doc = "A train entity in the simulation"
[types.Train.fields]
id = { type = "ID<Train>", doc = "Unique identifier", readonly = true }
tags = { type = "Tags", doc = "Tags attached to this train", readonly = true }

[types.Tag]
kind = "struct"
doc = "A tag that can be attached to game objects for grouping"
[types.Tag.fields]
id = { type = "ID<Tag>", doc = "Unique identifier", readonly = true }
parent_id = { type = "ID<Tag>", doc = "Parent tag ID", readonly = true }

[types.Motion]
kind = "struct"
doc = "Motion state of a train"
[types.Motion.fields]
train_id = { type = "ID<Train>", doc = "Train ID", readonly = true }
presence = { type = "std::optional<Motion::Presence>", doc = "Presence state", readonly = true }
drive = { type = "std::optional<Motion::Drive>", doc = "Drive state", readonly = true }
timed_stop = { type = "std::optional<Motion::TimedStop>", doc = "Timed stop state", readonly = true }
schedule_stop = { type = "std::optional<Motion::ScheduleStop>", doc = "Schedule stop state", readonly = true }
schedule_station_event = { type = "std::optional<Motion::ScheduleStationEvent>", doc = "Schedule station event state", readonly = true }
schedule_dispatch = { type = "std::optional<Motion::ScheduleDispatch>", doc = "Schedule dispatch state", readonly = true }
hitch = { type = "std::optional<Motion::Hitch>", doc = "Hitch state", readonly = true }

[types.SimController]
kind = "struct"
doc = "Controller for queuing simulation commands"

[[types.SimController.methods]]
name = "queue_train_intervention"
doc = "Queue a train intervention (despawn)"
[[types.SimController.methods.params]]
name = "train"
type = "&Train"

[[types.SimController.methods]]
name = "queue_train_warp"
doc = "Queue a train warp (reposition)"
[[types.SimController.methods.params]]
name = "train"
type = "&Train"
[[types.SimController.methods.params]]
name = "pos"
type = "&Pos"

[[types.SimController.methods]]
name = "queue_train_drive_to"
doc = "Queue a route modification"
[[types.SimController.methods.params]]
name = "train"
type = "&Train"
[[types.SimController.methods.params]]
name = "pos"
type = "&Pos"

[[types.SimController.methods]]
name = "queue_attach"
doc = "Queue attaching script data to an entity"
type_params = ["T"]
[[types.SimController.methods.params]]
name = "target"
type = "ID<GameObject>"
[[types.SimController.methods.params]]
name = "data"
type = "T"

[[types.SimController.methods]]
name = "queue_erase"
doc = "Queue erasing script data from an entity"
type_params = ["T"]
[[types.SimController.methods.params]]
name = "target"
type = "ID<GameObject>"

[[types.SimController.methods]]
name = "queue_task"
doc = "Queue a deferred task"
[[types.SimController.methods.params]]
name = "task"
type = "Task"

[[types.SimController.methods]]
name = "queue_task_at"
doc = "Queue a deferred task at a specific time"
[[types.SimController.methods.params]]
name = "task"
type = "Task"
[[types.SimController.methods.params]]
name = "time_us"
type = "i64"

# ============================================
# Enums
# ============================================

[enums.SignalCheck]
doc = "Result of a signal check event"
variants = [
    { name = "Pass", doc = "Allow the train to pass" },
    { name = "Stop", doc = "Stop the train at the signal" },
]

[enums.SignalAspect]
doc = "Visual aspect of a signal"
variants = [
    { name = "Clear", doc = "Signal shows clear" },
    { name = "Caution", doc = "Signal shows caution" },
    { name = "Danger", doc = "Signal shows danger/stop" },
]

[enums.SignalKind]
doc = "Type of signal"
variants = [
    { name = "Path", doc = "Path signal" },
    { name = "Balise", doc = "Balise signal" },
    { name = "Marker", doc = "Marker signal" },
    { name = "OneWay", doc = "One-way signal" },
    { name = "NoWay", doc = "No-way signal" },
    { name = "PlatformStop", doc = "Platform stop signal" },
]

[enums.SignalChangePath]
doc = "Result of signal change path event"
variants = [
    { name = "Keep", doc = "Keep current path" },
    { name = "Change", doc = "Change path" },
]

[enums.ShiftAllow]
doc = "Result of shift allow check"
variants = [
    { name = "Allow", doc = "Allow shift" },
    { name = "Deny", doc = "Deny shift" },
]

# ============================================
# Additional Game Types
# ============================================

[types.Building]
kind = "struct"
doc = "A building entity"
[types.Building.fields]
id = { type = "ID<Building>", doc = "Unique identifier", readonly = true }

[types.Line]
kind = "struct"
doc = "A transit line"
[types.Line.fields]
id = { type = "ID<Line>", doc = "Unique identifier", readonly = true }
tags = { type = "Tags", doc = "Tags attached to this line", readonly = true }

[types.Schedule]
kind = "struct"
doc = "A schedule definition"
[types.Schedule.fields]
id = { type = "ID<Schedule>", doc = "Unique identifier", readonly = true }
tags = { type = "Tags", doc = "Tags attached to this schedule", readonly = true }

[types.Station]
kind = "struct"
doc = "A station entity"
[types.Station.fields]
id = { type = "ID<Station>", doc = "Unique identifier", readonly = true }
tags = { type = "Tags", doc = "Tags attached to this station", readonly = true }

[types.Track]
kind = "struct"
doc = "A track segment"
[types.Track.fields]
id = { type = "ID<Track>", doc = "Unique identifier", readonly = true }
station_id = { type = "ID<Station>", doc = "Station ID for platform tracks (invalid if not a platform track)", readonly = true }

# Tags type
[types.Tags]
kind = "struct"
doc = "Collection of tags"

[[types.Tags.methods]]
name = "contains"
doc = "Check if tags contain a specific tag by ID"
return_type = "bool"
[[types.Tags.methods.params]]
name = "id"
type = "ID<Tag>"

[[types.Tags.methods]]
name = "contains"
doc = "Check if tags contain a specific tag"
return_type = "bool"
[[types.Tags.methods.params]]
name = "tag"
type = "&Tag"

# Position types
[types.Pos]
kind = "struct"
doc = "A position on the track"
[types.Pos.fields]
track_id = { type = "ID<Track>", doc = "Track segment ID", readonly = true }

[[types.Pos.methods]]
name = "flip"
doc = "Get flipped position"
return_type = "Pos"

[types.Pose]
kind = "struct"
doc = "A pose (head and tail positions)"
[types.Pose.fields]
head = { type = "Pos", doc = "Head position", readonly = true }
tail = { type = "Pos", doc = "Tail position", readonly = true }

[types.Path]
kind = "struct"
doc = "A path between positions"
[types.Path.fields]
found = { type = "bool", doc = "Whether path was found", readonly = true }
goal_has_stop_time = { type = "bool", doc = "Goal has stop time", readonly = true }
force_goal_reservation = { type = "bool", doc = "Force goal reservation", readonly = true }
pose_start = { type = "Pose", doc = "Start pose", readonly = true }
pose_goal = { type = "Pose", doc = "Goal pose", readonly = true }
found_start = { type = "Pos", doc = "Found start position", readonly = true }
found_goal = { type = "Pos", doc = "Found goal position", readonly = true }

[types.TapeTrace]
kind = "struct"
doc = "A trace along the track"

[[types.TapeTrace.methods]]
name = "contains"
doc = "Check if trace contains a position"
return_type = "bool"
[[types.TapeTrace.methods.params]]
name = "pos"
type = "&Pos"

[[types.TapeTrace.methods]]
name = "contains"
doc = "Check if trace contains another trace"
return_type = "bool"
[[types.TapeTrace.methods.params]]
name = "other"
type = "&TapeTrace"

[[types.TapeTrace.methods]]
name = "hits"
doc = "Check if traces intersect"
return_type = "bool"
[[types.TapeTrace.methods.params]]
name = "trace"
type = "&TapeTrace"

# ID generic type - wrapper for referencing game objects
[types."ID<Signal>"]
kind = "struct"
doc = "ID reference to a Signal entity"
[[types."ID<Signal>".methods]]
name = "empty"
doc = "Returns a sentinel empty ID value"
return_type = "ID<Signal>"
[[types."ID<Signal>".methods]]
name = "equals"
doc = "Compare two ID instances"
return_type = "bool"
[[types."ID<Signal>".methods.params]]
name = "other"
type = "ID<Signal>"

[types."ID<Train>"]
kind = "struct"
doc = "ID reference to a Train entity"
[[types."ID<Train>".methods]]
name = "empty"
doc = "Returns a sentinel empty ID value"
return_type = "ID<Train>"
[[types."ID<Train>".methods]]
name = "equals"
doc = "Compare two ID instances"
return_type = "bool"
[[types."ID<Train>".methods.params]]
name = "other"
type = "ID<Train>"

[types."ID<Tag>"]
kind = "struct"
doc = "ID reference to a Tag entity"
[[types."ID<Tag>".methods]]
name = "empty"
doc = "Returns a sentinel empty ID value"
return_type = "ID<Tag>"
[[types."ID<Tag>".methods]]
name = "equals"
doc = "Compare two ID instances"
return_type = "bool"
[[types."ID<Tag>".methods.params]]
name = "other"
type = "ID<Tag>"

[types."ID<Line>"]
kind = "struct"
doc = "ID reference to a Line entity"
[[types."ID<Line>".methods]]
name = "empty"
doc = "Returns a sentinel empty ID value"
return_type = "ID<Line>"
[[types."ID<Line>".methods]]
name = "equals"
doc = "Compare two ID instances"
return_type = "bool"
[[types."ID<Line>".methods.params]]
name = "other"
type = "ID<Line>"

[types."ID<Schedule>"]
kind = "struct"
doc = "ID reference to a Schedule entity"
[[types."ID<Schedule>".methods]]
name = "empty"
doc = "Returns a sentinel empty ID value"
return_type = "ID<Schedule>"
[[types."ID<Schedule>".methods]]
name = "equals"
doc = "Compare two ID instances"
return_type = "bool"
[[types."ID<Schedule>".methods.params]]
name = "other"
type = "ID<Schedule>"

[types."ID<Building>"]
kind = "struct"
doc = "ID reference to a Building entity"
[[types."ID<Building>".methods]]
name = "empty"
doc = "Returns a sentinel empty ID value"
return_type = "ID<Building>"
[[types."ID<Building>".methods]]
name = "equals"
doc = "Compare two ID instances"
return_type = "bool"
[[types."ID<Building>".methods.params]]
name = "other"
type = "ID<Building>"

[types."ID<Station>"]
kind = "struct"
doc = "ID reference to a Station entity"
[[types."ID<Station>".methods]]
name = "empty"
doc = "Returns a sentinel empty ID value"
return_type = "ID<Station>"
[[types."ID<Station>".methods]]
name = "equals"
doc = "Compare two ID instances"
return_type = "bool"
[[types."ID<Station>".methods.params]]
name = "other"
type = "ID<Station>"

[types."ID<Track>"]
kind = "struct"
doc = "ID reference to a Track entity"
[[types."ID<Track>".methods]]
name = "empty"
doc = "Returns a sentinel empty ID value"
return_type = "ID<Track>"
[[types."ID<Track>".methods]]
name = "equals"
doc = "Compare two ID instances"
return_type = "bool"
[[types."ID<Track>".methods.params]]
name = "other"
type = "ID<Track>"

[types."ID<Script>"]
kind = "struct"
doc = "ID reference to a Script entity"
[[types."ID<Script>".methods]]
name = "empty"
doc = "Returns a sentinel empty ID value"
return_type = "ID<Script>"
[[types."ID<Script>".methods]]
name = "equals"
doc = "Compare two ID instances"
return_type = "bool"
[[types."ID<Script>".methods.params]]
name = "other"
type = "ID<Script>"

[types.EventCtx]
kind = "struct"
doc = "Context for event handlers"
[types.EventCtx.fields]
db = { type = "&DB", doc = "Database access", readonly = true }
extrapolator = { type = "&Extrapolator", doc = "Extrapolator access", readonly = true }

# Motion substates
[types."Motion::Presence"]
kind = "struct"
doc = "Train presence state"
[types."Motion::Presence".fields]
pos = { type = "Pos", doc = "Current position", readonly = true }
speed = { type = "f64", doc = "Current speed in m/s", readonly = true }

[types."Motion::Drive"]
kind = "struct"
doc = "Train drive state"
[types."Motion::Drive".fields]
waiting_signal_id = { type = "ID<Signal>", doc = "Signal being waited on", readonly = true }
waiting_signal_last_check = { type = "i64", doc = "Last check time", readonly = true }
path = { type = "Path", doc = "Current path", readonly = true }
goal_trace = { type = "TapeTrace", doc = "Goal trace", readonly = true }

[types."Motion::TimedStop"]
kind = "struct"
doc = "Timed stop state"
[types."Motion::TimedStop".fields]
departure_epoch_s = { type = "i64", doc = "Departure time in epoch seconds", readonly = true }

[types."Motion::ScheduleStop"]
kind = "struct"
doc = "Schedule stop state"
[types."Motion::ScheduleStop".fields]
sched_id = { type = "ID<Schedule>", doc = "Schedule ID", readonly = true }
line_id = { type = "ID<Line>", doc = "Line ID", readonly = true }
station_id = { type = "ID<Station>", doc = "Station ID", readonly = true }

[types."Motion::Hitch"]
kind = "struct"
doc = "Hitch state"
[types."Motion::Hitch".fields]
driver_train_id = { type = "ID<Train>", doc = "Driver train ID", readonly = true }

[types."Motion::ScheduleStationEvent"]
kind = "struct"
doc = "Schedule station event state"

[types."Motion::ScheduleDispatch"]
kind = "struct"
doc = "Schedule dispatch state"
[types."Motion::ScheduleDispatch".fields]
sched_id = { type = "ID<Schedule>", doc = "Schedule ID", readonly = true }
run = { type = "Run", doc = "Current run", readonly = true }
run_epoch_start = { type = "i64", doc = "Run epoch start time", readonly = true }

# std::optional
[types."std::optional"]
kind = "struct"
doc = "Optional value wrapper"
type_params = ["T"]

[[types."std::optional".methods]]
name = "get"
doc = "Get pointer to contained value"
return_type = "*T"

# Run type
[types.Run]
kind = "struct"
doc = "A schedule run"
[types.Run.fields]
line_id = { type = "ID<Line>", doc = "Line ID", readonly = true }

# Shift type
[types.Shift]
kind = "struct"
doc = "A schedule shift"
[types.Shift.fields]
tags = { type = "Tags", doc = "Tags attached to this shift", readonly = true }

# Additional SimController methods
[[types.SimController.methods]]
name = "queue_train_hitch"
doc = "Queue hitching two trains together"
[[types.SimController.methods.params]]
name = "driver"
type = "&Train"
[[types.SimController.methods.params]]
name = "hitcher"
type = "&Train"

[[types.SimController.methods]]
name = "queue_train_unhitch"
doc = "Queue unhitching a train"
[[types.SimController.methods.params]]
name = "hitcher"
type = "&Train"

[[types.SimController.methods]]
name = "queue_train_set_configuration"
doc = "Queue setting train configuration"
[[types.SimController.methods.params]]
name = "train"
type = "&Train"
[[types.SimController.methods.params]]
name = "config"
type = "i64"

# Extrapolator methods
[[types.Extrapolator.methods]]
name = "clock_us"
doc = "Returns microseconds since game creation"
return_type = "i64"

[[types.Extrapolator.methods]]
name = "epoch_s"
doc = "Returns seconds since 1970-01-01"
return_type = "i64"

[[types.Extrapolator.methods]]
name = "week_s"
doc = "Returns current week second"
return_type = "i64"

[[types.Extrapolator.methods]]
name = "week_monday0000_epoch_s"
doc = "Returns epoch seconds of current week's Monday 00:00"
return_type = "i64"

[[types.Extrapolator.methods]]
name = "get_one_occupation"
doc = "Get one train occupying a position"
return_type = "*Train"
[[types.Extrapolator.methods.params]]
name = "pos"
type = "&Pos"
[[types.Extrapolator.methods.params]]
name = "ignore_train"
type = "ID<Train>"

[[types.Extrapolator.methods]]
name = "get_one_reservation"
doc = "Get one train reserving a position"
return_type = "*Train"
[[types.Extrapolator.methods.params]]
name = "pos"
type = "&Pos"
[[types.Extrapolator.methods.params]]
name = "ignore_train"
type = "ID<Train>"

[[types.Extrapolator.methods]]
name = "is_occupying"
doc = "Check if train is occupying a position"
return_type = "bool"
[[types.Extrapolator.methods.params]]
name = "pos"
type = "&Pos"
[[types.Extrapolator.methods.params]]
name = "train"
type = "ID<Train>"

[[types.Extrapolator.methods]]
name = "is_reserving"
doc = "Check if train is reserving a position"
return_type = "bool"
[[types.Extrapolator.methods.params]]
name = "pos"
type = "&Pos"
[[types.Extrapolator.methods.params]]
name = "train"
type = "ID<Train>"

[[types.Extrapolator.methods]]
name = "reservation_probe"
doc = "Probe reservations at a position"
return_type = "ScResvProbeIt"
[[types.Extrapolator.methods.params]]
name = "pos"
type = "&Pos"

# Iterator types
[types.ScResvProbeIt]
kind = "struct"
doc = "Reservation probe iterator"

[[types.ScResvProbeIt.methods]]
name = "next"
doc = "Get next probe result"
return_type = "*ScResvProbeIt::Result"

[types."ScResvProbeIt::Result"]
kind = "struct"
doc = "Reservation probe result"
[types."ScResvProbeIt::Result".fields]
is_occ = { type = "bool", doc = "Is occupation (vs reservation)", readonly = true }
train = { type = "&Train", doc = "The train", readonly = true }

# Vec types for reference fields in pub structs
# Allowed types: &Vec<ID<Line>>, &Vec<ID<Train>>, &Vec<ID<Schedule>>, &Vec<ID<Signal>>

[types."&Vec<ID<Line>>"]
kind = "struct"
doc = "Reference to a vector of Line IDs. Can be used as a field in pub structs. The game UI shows a mini listing editor for Vec fields."

[[types."&Vec<ID<Line>>".methods]]
name = "len"
doc = "Returns the number of elements"
return_type = "i64"

[[types."&Vec<ID<Line>>".methods]]
name = "is_empty"
doc = "Returns true if the vector contains no elements"
return_type = "bool"

[[types."&Vec<ID<Line>>".methods]]
name = "contains"
doc = "Returns true if the vector contains the given ID"
return_type = "bool"
[[types."&Vec<ID<Line>>".methods.params]]
name = "value"
type = "ID<Line>"

[[types."&Vec<ID<Line>>".methods]]
name = "get"
doc = "Returns a pointer to the element at the given index, or null if out of bounds"
return_type = "*ID<Line>"
[[types."&Vec<ID<Line>>".methods.params]]
name = "idx"
type = "i64"

[[types."&Vec<ID<Line>>".methods]]
name = "iter"
doc = "Returns an iterator for use in for-in loops"
return_type = "VecIter<ID<Line>>"

[types."&Vec<ID<Train>>"]
kind = "struct"
doc = "Reference to a vector of Train IDs. Can be used as a field in pub structs. The game UI shows a mini listing editor for Vec fields."

[[types."&Vec<ID<Train>>".methods]]
name = "len"
doc = "Returns the number of elements"
return_type = "i64"

[[types."&Vec<ID<Train>>".methods]]
name = "is_empty"
doc = "Returns true if the vector contains no elements"
return_type = "bool"

[[types."&Vec<ID<Train>>".methods]]
name = "contains"
doc = "Returns true if the vector contains the given ID"
return_type = "bool"
[[types."&Vec<ID<Train>>".methods.params]]
name = "value"
type = "ID<Train>"

[[types."&Vec<ID<Train>>".methods]]
name = "get"
doc = "Returns a pointer to the element at the given index, or null if out of bounds"
return_type = "*ID<Train>"
[[types."&Vec<ID<Train>>".methods.params]]
name = "idx"
type = "i64"

[[types."&Vec<ID<Train>>".methods]]
name = "iter"
doc = "Returns an iterator for use in for-in loops"
return_type = "VecIter<ID<Train>>"

[types."&Vec<ID<Schedule>>"]
kind = "struct"
doc = "Reference to a vector of Schedule IDs. Can be used as a field in pub structs. The game UI shows a mini listing editor for Vec fields."

[[types."&Vec<ID<Schedule>>".methods]]
name = "len"
doc = "Returns the number of elements"
return_type = "i64"

[[types."&Vec<ID<Schedule>>".methods]]
name = "is_empty"
doc = "Returns true if the vector contains no elements"
return_type = "bool"

[[types."&Vec<ID<Schedule>>".methods]]
name = "contains"
doc = "Returns true if the vector contains the given ID"
return_type = "bool"
[[types."&Vec<ID<Schedule>>".methods.params]]
name = "value"
type = "ID<Schedule>"

[[types."&Vec<ID<Schedule>>".methods]]
name = "get"
doc = "Returns a pointer to the element at the given index, or null if out of bounds"
return_type = "*ID<Schedule>"
[[types."&Vec<ID<Schedule>>".methods.params]]
name = "idx"
type = "i64"

[[types."&Vec<ID<Schedule>>".methods]]
name = "iter"
doc = "Returns an iterator for use in for-in loops"
return_type = "VecIter<ID<Schedule>>"

[types."&Vec<ID<Signal>>"]
kind = "struct"
doc = "Reference to a vector of Signal IDs. Can be used as a field in pub structs. The game UI shows a mini listing editor for Vec fields."

[[types."&Vec<ID<Signal>>".methods]]
name = "len"
doc = "Returns the number of elements"
return_type = "i64"

[[types."&Vec<ID<Signal>>".methods]]
name = "is_empty"
doc = "Returns true if the vector contains no elements"
return_type = "bool"

[[types."&Vec<ID<Signal>>".methods]]
name = "contains"
doc = "Returns true if the vector contains the given ID"
return_type = "bool"
[[types."&Vec<ID<Signal>>".methods.params]]
name = "value"
type = "ID<Signal>"

[[types."&Vec<ID<Signal>>".methods]]
name = "get"
doc = "Returns a pointer to the element at the given index, or null if out of bounds"
return_type = "*ID<Signal>"
[[types."&Vec<ID<Signal>>".methods.params]]
name = "idx"
type = "i64"

[[types."&Vec<ID<Signal>>".methods]]
name = "iter"
doc = "Returns an iterator for use in for-in loops"
return_type = "VecIter<ID<Signal>>"

# Vec iterators for for-in loops
[types."VecIter<ID<Line>>"]
kind = "struct"
doc = "Iterator for Vec<ID<Line>>, used in for-in loops"

[[types."VecIter<ID<Line>>".methods]]
name = "next"
doc = "Get next element"
return_type = "*ID<Line>"

[types."VecIter<ID<Train>>"]
kind = "struct"
doc = "Iterator for Vec<ID<Train>>, used in for-in loops"

[[types."VecIter<ID<Train>>".methods]]
name = "next"
doc = "Get next element"
return_type = "*ID<Train>"

[types."VecIter<ID<Schedule>>"]
kind = "struct"
doc = "Iterator for Vec<ID<Schedule>>, used in for-in loops"

[[types."VecIter<ID<Schedule>>".methods]]
name = "next"
doc = "Get next element"
return_type = "*ID<Schedule>"

[types."VecIter<ID<Signal>>"]
kind = "struct"
doc = "Iterator for Vec<ID<Signal>>, used in for-in loops"

[[types."VecIter<ID<Signal>>".methods]]
name = "next"
doc = "Get next element"
return_type = "*ID<Signal>"

# Signal result types
[types.SignalLookaheadResult]
kind = "struct"
doc = "Result of signal lookahead"
[types.SignalLookaheadResult.fields]
max_speed = { type = "f64", doc = "Maximum allowed speed", readonly = true }

[types.SignalChangePathResult]
kind = "struct"
doc = "Result of signal change path"
[types.SignalChangePathResult.fields]
pos = { type = "Pos", doc = "New position", readonly = true }
goal_has_stop_time = { type = "bool", doc = "Goal has stop time", readonly = true }
force_goal_reservation = { type = "bool", doc = "Force goal reservation", readonly = true }

# Shift types
[types.ShiftSetup]
kind = "struct"
doc = "Shift setup parameters"
[types.ShiftSetup.fields]
skip = { type = "bool", doc = "Skip shift" }
match_pos = { type = "bool", doc = "Match position" }
check_occupation = { type = "bool", doc = "Check occupation" }
pos = { type = "Pos", doc = "Position" }
epoch_s = { type = "i64", doc = "Epoch seconds" }

# ============================================
# Game Callbacks (valid public functions)
# ============================================
# These are the only functions that can be declared as `pub fn`
# because they are entry points called by the game engine

[[callbacks]]
name = "event_signal_check"
doc = "Called when a signal is checked during path validation"
for_type = "Signal"
return_type = "SignalCheck"
[[callbacks.params]]
name = "self"
type = "&Self"
[[callbacks.params]]
name = "ctx"
type = "&EventCtx"
[[callbacks.params]]
name = "train"
type = "&Train"
[[callbacks.params]]
name = "motion"
type = "&Motion"
[[callbacks.params]]
name = "signal"
type = "&Signal"

[[callbacks]]
name = "event_signal_lookahead"
doc = "Called at regular intervals for signals ahead of train"
for_type = "Signal"
[[callbacks.params]]
name = "self"
type = "&Self"
[[callbacks.params]]
name = "ctx"
type = "&EventCtx"
[[callbacks.params]]
name = "train"
type = "&Train"
[[callbacks.params]]
name = "motion"
type = "&Motion"
[[callbacks.params]]
name = "signal"
type = "&Signal"
[[callbacks.params]]
name = "train_distance"
type = "f64"
[[callbacks.params]]
name = "check"
type = "SignalCheck"
[[callbacks.params]]
name = "result"
type = "&mut SignalLookaheadResult"

[[callbacks]]
name = "event_signal_change_path"
doc = "Called when signal can modify train routing"
for_type = "Signal"
return_type = "SignalChangePath"
[[callbacks.params]]
name = "self"
type = "&Self"
[[callbacks.params]]
name = "ctx"
type = "&EventCtx"
[[callbacks.params]]
name = "train"
type = "&Train"
[[callbacks.params]]
name = "motion"
type = "&Motion"
[[callbacks.params]]
name = "signal"
type = "&Signal"
[[callbacks.params]]
name = "check"
type = "SignalCheck"
[[callbacks.params]]
name = "result"
type = "&mut SignalChangePathResult"

[[callbacks]]
name = "event_signal_pass_by"
doc = "Called when train passes exact signal location"
for_type = "Signal"
[[callbacks.params]]
name = "self"
type = "&Self"
[[callbacks.params]]
name = "ctx"
type = "&EventCtx"
[[callbacks.params]]
name = "train"
type = "&Train"
[[callbacks.params]]
name = "motion"
type = "&Motion"
[[callbacks.params]]
name = "signal"
type = "&Signal"
[[callbacks.params]]
name = "sc"
type = "&mut SimController"

[[callbacks]]
name = "event_signal_marker_reserved"
doc = "Queries reservation status for marker signals"
for_type = "Signal"
return_type = "ID<Train>"
[[callbacks.params]]
name = "self"
type = "&Self"
[[callbacks.params]]
name = "db"
type = "&DB"
[[callbacks.params]]
name = "signal"
type = "&Signal"

[[callbacks]]
name = "event_signal_texture_state"
doc = "Returns visual state index for signal rendering"
for_type = "Signal"
return_type = "i64"
[[callbacks.params]]
name = "self"
type = "&Self"
[[callbacks.params]]
name = "db"
type = "&DB"
[[callbacks.params]]
name = "signal"
type = "&Signal"

[[callbacks]]
name = "event_train_shift_setup"
doc = "Influences shift selection for unassigned trains"
for_type = "Train"
[[callbacks.params]]
name = "self"
type = "&Self"
[[callbacks.params]]
name = "ctx"
type = "&EventCtx"
[[callbacks.params]]
name = "train"
type = "&Train"
[[callbacks.params]]
name = "motion"
type = "&Motion"
[[callbacks.params]]
name = "ss"
type = "&mut ShiftSetup"

[[callbacks]]
name = "event_train_shift_allow"
doc = "Approves or denies candidate shifts for trains"
for_type = "Train"
return_type = "ShiftAllow"
[[callbacks.params]]
name = "self"
type = "&Self"
[[callbacks.params]]
name = "ctx"
type = "&EventCtx"
[[callbacks.params]]
name = "train"
type = "&Train"
[[callbacks.params]]
name = "motion"
type = "&Motion"
[[callbacks.params]]
name = "sched"
type = "&Schedule"
[[callbacks.params]]
name = "shift"
type = "&Shift"
[[callbacks.params]]
name = "run"
type = "&Run"
[[callbacks.params]]
name = "stop_idx"
type = "i64"
[[callbacks.params]]
name = "arrival_us"
type = "i64"
[[callbacks.params]]
name = "pose"
type = "&Pose"

[[callbacks]]
name = "control_train"
doc = "Executes periodically (every 6 sim-seconds) for train manipulation"
for_type = "Controller"
[[callbacks.params]]
name = "self"
type = "&Self"
[[callbacks.params]]
name = "ctx"
type = "&ControlCtx"
[[callbacks.params]]
name = "train"
type = "&Train"
[[callbacks.params]]
name = "motion"
type = "&Motion"
[[callbacks.params]]
name = "sc"
type = "&mut SimController"

[[callbacks]]
name = "task_run"
doc = "Executes queued task with single-threaded data consistency"
for_type = "Controller"
[[callbacks.params]]
name = "self"
type = "&Self"
[[callbacks.params]]
name = "ctx"
type = "&ControlCtx"
[[callbacks.params]]
name = "sc"
type = "&mut SimController"
