script meta {
    lang: nimbyscript.v1,
    api: nimbyrails.v1,
}

// Struct with various complex type fields that are valid for pub structs
pub struct TypeTest extend Signal {
    meta { label: "Type Test" },

    // ID generics (valid for pub structs)
    signal_id: ID<Signal>,
    train_id: ID<Train>,
    schedule_id: ID<Schedule>,
    line_id: ID<Line>,
    tag_id: ID<Tag>,

    // Simple types (valid for pub structs)
    count: i64,
    ratio: f64,
    enabled: bool,
}

// Enum definition
enum Status {
    Active,
    Inactive,
    Pending,
}

// Struct using user-defined enum (valid)
pub struct StatusHolder extend Signal {
    meta { label: "Status Holder" },
    current_status: Status,
}

// Private struct can use any types
struct InternalData {
    value: i64,
    train: ID<Train>,
}

// Callback that uses complex types
pub fn TypeTest::event_signal_check(
    self: &TypeTest,
    ctx: &EventCtx,
    train: &Train,
    motion: &Motion,
    signal: &Signal
): SignalCheck {
    // Using ID<T>::empty() static method
    let empty_train = ID<Train>::empty();

    // Using ID<T>.equals() method on a struct field
    // This tests that generic type method resolution uses ID<Signal>, not Signal
    if self.signal_id.equals(signal.id) {
        return SignalCheck::Stop;
    }

    // Using is_valid with optional types
    let view_result &= ctx.db.view(self.train_id) else {
        return SignalCheck::Pass;
    }

    // Using count field
    if self.count > 0 {
        return SignalCheck::Stop;
    }

    return SignalCheck::Pass;
}

// Callback that uses private struct
struct TaskData {
    counter: i64,
}

pub fn TaskData::task_run(
    self: &TaskData,
    ctx: &ControlCtx,
    sc: &mut SimController
) {
    log("counter: @", self.counter);
}

// Callback that tests optional unwrapping
pub fn StatusHolder::event_signal_check(
    self: &StatusHolder,
    ctx: &EventCtx,
    train: &Train,
    motion: &Motion,
    signal: &Signal
): SignalCheck {
    // Using optional field access
    let drive &= motion.drive.get() else {
        return SignalCheck::Pass;
    }

    // Testing enum comparison
    if self.current_status == Status::Active {
        return SignalCheck::Pass;
    }

    return SignalCheck::Stop;
}
