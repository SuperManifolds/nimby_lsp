script meta {
    lang: nimbyscript.v1,
    api: nimbyrails.v1,
}

// Signal callbacks
pub struct SignalHandler extend Signal {
    meta { label: "Signal Handler" },
}

pub fn SignalHandler::event_signal_check(
    self: &SignalHandler,
    ctx: &EventCtx,
    train: &Train,
    motion: &Motion,
    signal: &Signal
): SignalCheck {
    return SignalCheck::Pass;
}

pub fn SignalHandler::event_signal_lookahead(
    self: &SignalHandler,
    ctx: &EventCtx,
    train: &Train,
    motion: &Motion,
    signal: &Signal,
    train_distance: f64,
    check: SignalCheck,
    result: &mut SignalLookaheadResult
) {
    // No-op
}

pub fn SignalHandler::event_signal_change_path(
    self: &SignalHandler,
    ctx: &EventCtx,
    train: &Train,
    motion: &Motion,
    signal: &Signal,
    check: SignalCheck,
    result: &mut SignalChangePathResult
): SignalChangePath {
    return SignalChangePath::Keep;
}

pub fn SignalHandler::event_signal_pass_by(
    self: &SignalHandler,
    ctx: &EventCtx,
    train: &Train,
    motion: &Motion,
    signal: &Signal,
    sc: &mut SimController
) {
    // No-op
}

pub fn SignalHandler::event_signal_marker_reserved(
    self: &SignalHandler,
    db: &DB,
    signal: &Signal
): ID<Train> {
    return ID<Train>::empty();
}

pub fn SignalHandler::event_signal_texture_state(
    self: &SignalHandler,
    db: &DB,
    signal: &Signal
): i64 {
    return 0;
}

// Train callbacks
pub struct TrainHandler extend Train {
    meta { label: "Train Handler" },
}

pub fn TrainHandler::event_train_shift_setup(
    self: &TrainHandler,
    ctx: &EventCtx,
    train: &Train,
    motion: &Motion,
    ss: &mut ShiftSetup
) {
    // No-op
}

pub fn TrainHandler::event_train_shift_allow(
    self: &TrainHandler,
    ctx: &EventCtx,
    train: &Train,
    motion: &Motion,
    sched: &Schedule,
    shift: &Shift,
    run: &Run,
    stop_idx: i64,
    arrival_us: i64,
    pose: &Pose
): ShiftAllow {
    return ShiftAllow::Allow;
}

pub fn TrainHandler::control_train(
    self: &TrainHandler,
    ctx: &ControlCtx,
    train: &Train,
    motion: &Motion,
    sc: &mut SimController
) {
    // No-op
}

// Task callback (private struct)
struct MyTask {
    data: i64,
}

pub fn MyTask::task_run(
    self: &MyTask,
    ctx: &ControlCtx,
    sc: &mut SimController
) {
    // No-op
}
