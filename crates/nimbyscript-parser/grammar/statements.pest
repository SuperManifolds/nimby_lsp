// NimbyScript PEG Grammar - Statements
// All statement types and control flow

block_stmt = { "{" ~ stmt* ~ "}" }

stmt = {
    if_bind_stmt
    | if_stmt
    | for_stmt
    | bind_else_stmt
    | bind_stmt
    | assign_stmt
    | ret_stmt
    | break_stmt
    | continue_stmt
    | log_stmt
    | exp_stmt
}

// Variable binding: let x = expr;
bind_stmt = { "let" ~ bind_body ~ ";" }

// Variable binding with else: let x = expr else { ... }
bind_else_stmt = { "let" ~ bind_body ~ "else" ~ block_stmt }

// Binding body: name with optional type annotation and binding mode
// Supports: let x = e, let x: T = e, let x &= e (ref), let x &mut= e (mut ref)
bind_body = { NAME ~ bind_type_sep? ~ bind_op ~ exp }
bind_type_sep = { ":" ~ type_pattern? }
bind_op = { "&mut=" | "mut=" | "&=" | "=" }

// Assignment: x.y.z = expr;
assign_stmt = { dot_exp ~ "=" ~ exp ~ ";" }

// If statement: if expr { ... } else { ... }
if_stmt = { "if" ~ exp ~ block_stmt ~ else_clause? }

// If-let statement: if let x = expr { ... }
if_bind_stmt = { "if" ~ "let" ~ bind_body ~ block_stmt ~ else_clause? }

// Else clause (can chain if/if-let)
else_clause = { "else" ~ (if_stmt | if_bind_stmt | block_stmt) }

// For loop: for x in expr { ... }
for_stmt = { "for" ~ NAME ~ "in" ~ exp ~ block_stmt }

// Control flow statements
break_stmt = { "break" ~ ";" }
continue_stmt = { "continue" ~ ";" }
ret_stmt = { "return" ~ exp? ~ ";" }

// Debug logging: log("message", args);
log_stmt = { "log" ~ "(" ~ string_literal ~ ("," ~ call_args)? ~ ")" ~ ";" }

// Expression statement: expr;
exp_stmt = { exp ~ ";" }
